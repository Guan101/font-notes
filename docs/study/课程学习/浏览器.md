## 浏览器体系
### 一、认识在浏览器运行态下的JS
#### 包含：BOM、DOM、ECMAScript
```js
 (function(context,undefined){
    const _class = ['js','brower,'vue']

    //向全局中挂载
    window.classArr = _class.map(item => item)

    //获取当前页面地址
    const _url = location.href

    //设置tab标题
    document.title = 'zhaowa class'

    //获取主渲染节点
    document.getElementById('app')
 })(this)

    //  追问：了解浏览器JS的执行态
    //简述
    //ECMAScript - 基础逻辑、数据处理
    //DOM - 对于浏览器视窗内、文本的相应操作
    //BOM - 对于浏览器本身区域能力的处理
```

### 二、BOM
#### 1.location
location.href = 'https://www.zhaowa.com/search?class=browser#comments' =>路径拦所有
        .origin =>'https://www.zhaowa.com'
        .protocol => 'https:'
        .port => ''
        .pathname => '/search/'
        .search => '?class=browser'
        .hash => '#comments'
        .assign('') //跳转到指定path => 替换pathname
        .replace('') //同上，同时替换浏览历史
        .reload()
        .toString() //产出当前地址字符串

* 面试方向：
1.location本身api操作 - 提取相关信息、api间对比 => assign vs replace
2.路由相关：跳转、参数、操作 => 场景：可返回（history）、是否刷新（hash） => replace替换为assign；携带参数跳回（第三方页面跳回）
3.url处理 -正则 or 手写js处理
4.URI & URL ： uniform resource identifier/locator
    URI：文件本身id(指向文件)
    URL:当前资源定位的地址信息（文件存放的路径）

#### history

history 和 hash 利弊：两者都是不刷新前端页面，hash会多一个#，history会出现后台解析不了的情况（因为就是真实路由，后台解析不了，所以给后台一个默认指向）

history.state => 存储当前页面的状态
history模式和hash模式一样不会改变浏览器的运行刷新状态，通过push的方式实现了不刷新的状态改变，同时可以回到上次状态。
hostory.pushState()
        .replaceState()

* 面试方向 - 路由方向，history和hash的模式利弊

### navigator
* 浏览器信息系统大集合
```js
        navigator.userAgent //获取用户的环境信息

```
* 面试方向
1、userAgent 读取信息 => 浏览器兼容性、上报信息
2、剪切板、键盘

#### 4、screen
表征显示区域 - 提供完整的荧幕的信息
* 面试方向 - 判断区域大小
window 视窗判断：
   全局入口处；
      window.innnerHeight
      window.innerWidth
   文本处获取；
      document.documentElement.clientHeight
      document.documentElement.clientWidth
      document.body.clientWidth
      document.body.clientHight
   网页视图的size -> offsetHight = clientHeight + 滚动条 + 边框 
       document.documentElement.offsetHeight
       document.documentElement.offsetWidth
       document.body.offsetHight
       document.body.offsetWidth 

   动态定位：
        scrollLeft / scrollTop - 距离常规左 / 上 滚动距离
        offsetLeft / offsetTop - 距离常规左 / 上 距离

el.getBoundingClientRect()
  el.getBoundingClientRect().left
  el.getBoundingClientRect().bottom
  el.getBoundingClientRect().right
  el.getBoundingClientRect().right
* 兼容性 - IE上会多出来2像素

### 三、 Event 事件模型
```js
        <div id='app'>
          <p id='dom'></p>
        </div>

        //冒泡 - ms:p => div => body => html => document
        //捕获 - ns:document => HTML => body => div => p

        el.addEventListener(event,function,useCapture)  //默认false


        //追问：
        //1.如果阻止事件的传播
        event.stopProgation()
        //注意：阻止传递行为 => 无法阻止默认事件

        //2.阻止默认事件 -比如 a自带的跳转
        event.preventDefault()

        //3.相同节点绑定多个同类事件
        event.stopImmediatePropagation()

        //引申型面试核心： 兼容性 & 性能
        //4. 手写兼容性事件绑定
        // 考察 IE - attachEvent vs addEventListener
        //区别：
        //a.传参： attachEvent 对于事件名需要加上'on'
        //b.执行书序： attachEvent - 后绑定执行 ； addEventListener先绑定后执行
        //c.解绑： detachEvent vs removeEventListener
        //d.阻断： event.cancelBubble = true vs event.stopPropagation()
        //e.默认事件拦截：event.returnValue = false vs event.preventDefault()

        class bindEvent{
                constructor(element){
                        this.element = element;
                }
                //绑定
                addEventListener = (type,handle) => {
                        if(this.element.addEventListener){
                                this.element.addEventListener(type,handle,false)
                        } else if(this.element.attachEvent){
                                this.element.attachEvent('on' + type,() =>{
                                        handler.call(element);
                                })
                        } else {
                                this.element['on' + type] = handler
                        }
                }
                
                //解绑
                removeEventListener = (type,handle) => {
                        if(this.element.addEventListener){
                                this.element.removeEventListener(type,handle,false)
                        } else if(this.element.attachEvent){
                                this.element.detachEvent('on' + type,() =>{
                                        handler.call(element);
                                })
                        } else {
                                this.element['on' + type] = null
                        }
                }

                //阻断
                static stopPropagation(e){
                        if(e.stopPropagation){
                                e.stopPropagation()
                        } else {
                                e.cancleBubble = true;
                        }
                }

                //默认拦截
                static preventDefault(e){
                        if(e.preventDefault){
                                e.preventDefault()
                        }else{
                                e.returnValue = false
                        }
                } 
        }

        //5.性能优化 -事件代理
        <ul class='list'>
           <li>1</li>
           <li>2</li>
           <li>3</li>
           <li>4</li>
           <li>5</li>
           <li>6</li>
        </ul>

        <div class="content"></div>

        var list = document.querySelector

